# Rails

Follows convention over configuration

```
rails new nameofapp

rails server
```

__Files under `app` directory are automatically required.__

## Models

Models are named plural by convention.

## Controllers

Controllers are named singular by convention.

```
rails generate controller nameoffcontroller [action1] [action2] // equivalent to rails g controller...
```

Generates a nameofcontroller_controller.rb file in `app/controllers`

```Ruby
class NameOfControllerController < ApplicationController
    def action1
    end
    def action2
    end
end
```

### Passing vars to the view

The instance variables that are defined in the controller actions `@name`, are available in the view

## View

Rails uses an .erb file for views. Embedded Ruby. It's a templating library that lets you embed Ruby code in HTML.

View files are in `app/views` and under the respective controller folder and are named after the functions in the controller.

So if you have a `greeter_controller.rb` controller, you (or the generator) will can create views for the controller's methods in `app/views/greeter` and name them after the function names. If you have a `hello` method in the controller, the corresponding view would be in `app/views/greeter/hello.html.erb`

It is always between these tags:

```
<% %> // evaluate Ruby code
<%= %> // evaluate && print Ruby code
```


- If the method of in the controller is not doing anything, you can safely remove it.
- As long as there is a **proper route defined** and there is a **properly named view file/template**, the method does not have to be there. Rails will find the correct template by convention
- The view files should have as little logic as possible


## Routing

You must always specify the routes by hand. (boring) in the `config/routes.rb` file. The generator creates them for you automatically if you generate a controller.

```Ruby
Rails.application.routes.draw do
    # One way of defining routes:
    get 'greeter/hello'

    # More specific (to other actions):
    # get 'path/to/route' => "controller#action"

    get 'greeter/howareu' => "greeter#hello"
end
```

## Rake

Ruby's equivalent of `make`. It is Ruby's build language. Written entirely in Ruby.

Rails uses Rake to automate app-related tasks like Database population or running tests.

```
rake --tasks # to see all of the tasks available
rake --describe sometaskname # describe what the rake task does

# Example: 
rake --describe routes # Lets you see which routes are currently defined for the application

# Run a task:
rake routes
```

## Helpers

**VIEW** helpers. Reusable code that goes in views. Live in `app/helpers` and are also generated by the generator. They are Ruby modules.

```Ruby
module GreeterHelper
    def formatted_time(time) # available in ALL the views application-wide
        # time string in AM/PM format
        time.strftime("%I:%M%p")
    end
end
```

Instantiating it an the view:


**app/views/greeter/hello.html.erb**
```HTML
<h1>Greetings, <%= @name %></h1>
<p>The time is now <%= formatted_time(@time) %></p>
```

Rails provides many built-in helpers. The prefix column vars shown in `rake routes` will allow you to embed relative or external URLs in your views via the `link_to` (relative) or `_url` (full path) or `_path` (interchangebly used with `url`) helpers:

```Ruby

```


### `link_to`

```HTML
<p><%= link_to "Google", "http://google.com" %></p>
<p><%= link_to "Goodbye", greeter_goodbye_path %></p> <!-- derived from routes.rb (see Prefix column in rake routes) -->
```


### `image_tag`

```Ruby
# something.erb
<% image_tag(source, options={}) %>
```

Image tag is another helper that outputs, as you might expect, an image tag.



## Ruby Gems

Ruby Gems are just 3rd party plugins for Ruby. `gem` is the package manager for gems that comes with Ruby. (Do `gem list` on the terminal to see gems installed)

Details about a gem

```
$ gem list nameofgem -d # short for describe
```

### HTTParty

Client for RESTful web services. Automatic parsing of JSON and XML into Ruby hashes.

Provides support for:

- basic HTTP authentication
- Default request query parameters

#### Using HTTParty

```Ruby
include HTTParty
```

You're good to go! You can then specify:

- `base_uri` for your requests
- `default_params` (e.g. API key)
- `format` to tell it what format to parse the data in 

```Ruby
require 'httparty'
require 'pp' # prettyPrint

class Coursera
    include HTTParty
    base_uri 'https://api.coursera.org/api/catalog.v1/courses'
    default_params fields: 'smallIcon, shortDescription', q:'search'
    format: json

    def self.for term
        get("", query:{query:term})["elements"] # HTTParty specific
    end
end

pp Coursera.for "python"
```

### Bundler

Lets you specify gems (and versions) and associated dependencies for the app inside the `Gemfile` in the root of the app. It is the preferred way to manage dependencies in Rails

Installing and updating gems:

```
bundle install
bundle update
```

**Note:** When you run these, you have to **restart the server**.

You can tell Rails to only load specific gems for specific environments in the Gemfile:

```Ruby
group :development, :test do
    # Call 'byebug' anywhere in the code to stop execution and get a debugger console
    gem 'byebug'

    # Access an IRB console on exception pages or by using <%= console %> in views
    gem 'web-console', '~> 2.0'

    # Spring speeds up development by keeping your application in the background
    gem 'spring'
end
```

You can specify versions. If you don't, you get the latest.

```Ruby
gem "rack", ">=1.0"
gem "thin", ">=1.1", "< 2.0"
gem "thin", "~>1.1" // pessimistic version constraint equals the above
```

Bundle also requires the gem on application start.

Occasionally, the name of the gem to be used inside the require statement is different than the name of the gem

```Ruby
gem 'sqlite3-ruby', require: 'sqlite3'
```



# ActiveRecord

### Scaffolding

- Essenttially a code generator for Entities
- Will create model, views and controllers for a particular model for CRUD operations

```
$ rails g scaffold nameofmodel [attr1] [attr2] [attr3:type]


$ rails g scaffold car make color year:integer
```

At this point, you have the Ruby code that the scaffolding created, but your database does not know. You have to run

```
$ rake db:migrate
```

To migrate the database

##### JSON

Scaffolding also generates JSON responses. All you have to do is add a .json extension to your url: 

```
http://localhost:3000/cars.json
```

to get the JSON response.


### Databases in Rails

By default, Rails uses SQLite. It is serverless, self-contained. It basically works with a single file that sits on your file system. You can modify this configuration in the `/config/database.yml` file in your application. You can get a SQLite terminal by running `rails db` in your Terminal.

Tables in Rails are always named plural.

By default, when doing migrations Rails adds a an `id` (which is `AUTO_INCREMENT`), a `created_at` and an `updated_at` column on your DB tables.

### Migrations

```Ruby
class CreateCars < ActiveRecord::Migration
    def change
      create_table :cars do |t|
        t.string :make
        t.string :color
        t.integer :year
        t.timestamps null: false
      end
    end
end
```

Ability to monitor and undo changes to DB. Ruby code to make changes to DBs schema __without using SQL regardless of what database engine your application is using__.

Ruby classes that extend ActiveRecord::Migration. They are basically files that have to be named following a specific format:

timesstamp_nameofclass.rb

And timestamp has to be of format year-month-date-hour-minute-second.

Example: 20150907153643_create_cars.rb

The timestamp defines the sequence in which the migrations are applied to a database. These migrations are located in `db/migrate`. Scaffolding creates a migration file unless passed a `--no-migration` flag. There is also an explicit migration generator. You can also write them by hand. Once a migration is generated it needs to be applied to the databse (via `rake db:migrate`). No two migrations can have the same name. Migration maintains a table called `schema_migrations` in your DB for bookkeeping.


#### Format

- `def up` 
    - Generate db schema changes (create table)
- `def down`
    - Undo the changes introduced by the `up` method

Or just `change` method where Rails chan guess how to undo changes.

You can rollback a migration using `rails db:rollback`


```
# Adding price to cars table
$  rails g migration add_price_to_cars 'price:decimal[10,2}'
```

which will generate the following migration:

```Ruby
class AddPriceToCars < ActiveRecord::Migration
  def change
    add_column :cars, :price, :decimal, precision: 10, scale: 2
  end
end
```

You also have a `schema.rb` file in `db` folder, which is the latest snapshot of your DB schema. You normally don't modify this. It is auto-generated.